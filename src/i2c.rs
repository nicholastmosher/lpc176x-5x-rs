# ! [ doc = "I2C bus interface" ]

use core::ops::Deref;
use cortex_m::peripheral::Peripheral;

# [ doc = "I2C bus interface" ]
pub const I2C0: Peripheral<I2C0> = unsafe { Peripheral::new(1073856512) };
use vcell::VolatileCell;
# [ doc = r" Register block" ]
# [ repr ( C ) ]
pub struct RegisterBlock {
    # [ doc = "0x00 - I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register." ]
    pub conset: CONSET,
    # [ doc = "0x04 - I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed." ]
    pub stat: STAT,
    # [ doc = "0x08 - I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register." ]
    pub dat: DAT,
    # [ doc = "0x0c - I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ]
    pub adr0: ADR0,
    # [ doc = "0x10 - SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock." ]
    pub sclh: SCLH,
    # [ doc = "0x14 - SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. SCLL and SCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode." ]
    pub scll: SCLL,
    # [ doc = "0x18 - I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register." ]
    pub conclr: CONCLR,
    # [ doc = "0x1c - Monitor mode control register." ]
    pub mmctrl: MMCTRL,
    # [ doc = "0x20 - I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ]
    pub adr1: ADR,
    # [ doc = "0x24 - I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ]
    pub adr2: ADR,
    # [ doc = "0x28 - I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ]
    pub adr3: ADR,
    # [ doc = "0x2c - Data buffer register. The contents of the 8 MSBs of the DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus." ]
    pub data_buffer: DATA_BUFFER,
    # [ doc = "0x30 - I2C Slave address mask register" ]
    pub mask0: MASK,
    # [ doc = "0x34 - I2C Slave address mask register" ]
    pub mask1: MASK,
    # [ doc = "0x38 - I2C Slave address mask register" ]
    pub mask2: MASK,
    # [ doc = "0x3c - I2C Slave address mask register" ]
    pub mask3: MASK,
}
# [ doc = "I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register." ]
pub struct CONSET {
    register: VolatileCell<u32>,
}
# [ doc = "I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register." ]
pub mod conset {
    # [ doc = r" Value read from the register" ]
    pub struct R {
        bits: u32,
    }
    # [ doc = r" Value to write to the register" ]
    pub struct W {
        bits: u32,
    }
    impl super::CONSET {
        # [ doc = r" Modifies the contents of the register" ]
        # [ inline ( always ) ]
        pub fn modify<F>(&self, f: F)
            where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
        {
            let bits = self.register.get();
            let r = R { bits: bits };
            let mut w = W { bits: bits };
            f(&r, &mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Reads the contents of the register" ]
        # [ inline ( always ) ]
        pub fn read(&self) -> R {
            R { bits: self.register.get() }
        }
        # [ doc = r" Writes to the register" ]
        # [ inline ( always ) ]
        pub fn write<F>(&self, f: F)
            where F: FnOnce(&mut W) -> &mut W
        {
            let mut w = W::reset_value();
            f(&mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Writes the reset value to the register" ]
        # [ inline ( always ) ]
        pub fn reset(&self) {
            self.write(|w| w)
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct AAR {
        bits: bool,
    }
    impl AAR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bit(&self) -> bool {
            self.bits
        }
        # [ doc = r" Returns `true` if the bit is clear (0)" ]
        # [ inline ( always ) ]
        pub fn is_clear(&self) -> bool {
            !self.bit()
        }
        # [ doc = r" Returns `true` if the bit is set (1)" ]
        # [ inline ( always ) ]
        pub fn is_set(&self) -> bool {
            self.bit()
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct SIR {
        bits: bool,
    }
    impl SIR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bit(&self) -> bool {
            self.bits
        }
        # [ doc = r" Returns `true` if the bit is clear (0)" ]
        # [ inline ( always ) ]
        pub fn is_clear(&self) -> bool {
            !self.bit()
        }
        # [ doc = r" Returns `true` if the bit is set (1)" ]
        # [ inline ( always ) ]
        pub fn is_set(&self) -> bool {
            self.bit()
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct STOR {
        bits: bool,
    }
    impl STOR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bit(&self) -> bool {
            self.bits
        }
        # [ doc = r" Returns `true` if the bit is clear (0)" ]
        # [ inline ( always ) ]
        pub fn is_clear(&self) -> bool {
            !self.bit()
        }
        # [ doc = r" Returns `true` if the bit is set (1)" ]
        # [ inline ( always ) ]
        pub fn is_set(&self) -> bool {
            self.bit()
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct STAR {
        bits: bool,
    }
    impl STAR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bit(&self) -> bool {
            self.bits
        }
        # [ doc = r" Returns `true` if the bit is clear (0)" ]
        # [ inline ( always ) ]
        pub fn is_clear(&self) -> bool {
            !self.bit()
        }
        # [ doc = r" Returns `true` if the bit is set (1)" ]
        # [ inline ( always ) ]
        pub fn is_set(&self) -> bool {
            self.bit()
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct I2ENR {
        bits: bool,
    }
    impl I2ENR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bit(&self) -> bool {
            self.bits
        }
        # [ doc = r" Returns `true` if the bit is clear (0)" ]
        # [ inline ( always ) ]
        pub fn is_clear(&self) -> bool {
            !self.bit()
        }
        # [ doc = r" Returns `true` if the bit is set (1)" ]
        # [ inline ( always ) ]
        pub fn is_set(&self) -> bool {
            self.bit()
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _AAW<'a> {
        w: &'a mut W,
    }
    impl<'a> _AAW<'a> {
        # [ doc = r" Sets the field bit" ]
        pub fn set(self) -> &'a mut W {
            self.bit(true)
        }
        # [ doc = r" Clears the field bit" ]
        pub fn clear(self) -> &'a mut W {
            self.bit(false)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 2;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _SIW<'a> {
        w: &'a mut W,
    }
    impl<'a> _SIW<'a> {
        # [ doc = r" Sets the field bit" ]
        pub fn set(self) -> &'a mut W {
            self.bit(true)
        }
        # [ doc = r" Clears the field bit" ]
        pub fn clear(self) -> &'a mut W {
            self.bit(false)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 3;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _STOW<'a> {
        w: &'a mut W,
    }
    impl<'a> _STOW<'a> {
        # [ doc = r" Sets the field bit" ]
        pub fn set(self) -> &'a mut W {
            self.bit(true)
        }
        # [ doc = r" Clears the field bit" ]
        pub fn clear(self) -> &'a mut W {
            self.bit(false)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 4;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _STAW<'a> {
        w: &'a mut W,
    }
    impl<'a> _STAW<'a> {
        # [ doc = r" Sets the field bit" ]
        pub fn set(self) -> &'a mut W {
            self.bit(true)
        }
        # [ doc = r" Clears the field bit" ]
        pub fn clear(self) -> &'a mut W {
            self.bit(false)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 5;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _I2ENW<'a> {
        w: &'a mut W,
    }
    impl<'a> _I2ENW<'a> {
        # [ doc = r" Sets the field bit" ]
        pub fn set(self) -> &'a mut W {
            self.bit(true)
        }
        # [ doc = r" Clears the field bit" ]
        pub fn clear(self) -> &'a mut W {
            self.bit(false)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 6;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    impl R {
        # [ doc = r" Value of the register as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u32 {
            self.bits
        }
        # [ doc = "Bit 2 - Assert acknowledge flag." ]
        # [ inline ( always ) ]
        pub fn aa(&self) -> AAR {
            let bits = {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                ((self.bits >> OFFSET) & MASK as u32) != 0
            };
            AAR { bits }
        }
        # [ doc = "Bit 3 - I2C interrupt flag." ]
        # [ inline ( always ) ]
        pub fn si(&self) -> SIR {
            let bits = {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                ((self.bits >> OFFSET) & MASK as u32) != 0
            };
            SIR { bits }
        }
        # [ doc = "Bit 4 - STOP flag." ]
        # [ inline ( always ) ]
        pub fn sto(&self) -> STOR {
            let bits = {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                ((self.bits >> OFFSET) & MASK as u32) != 0
            };
            STOR { bits }
        }
        # [ doc = "Bit 5 - START flag." ]
        # [ inline ( always ) ]
        pub fn sta(&self) -> STAR {
            let bits = {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                ((self.bits >> OFFSET) & MASK as u32) != 0
            };
            STAR { bits }
        }
        # [ doc = "Bit 6 - I2C interface enable." ]
        # [ inline ( always ) ]
        pub fn i2en(&self) -> I2ENR {
            let bits = {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                ((self.bits >> OFFSET) & MASK as u32) != 0
            };
            I2ENR { bits }
        }
    }
    impl W {
        # [ doc = r" Reset value of the register" ]
        # [ inline ( always ) ]
        pub fn reset_value() -> W {
            W { bits: 0 }
        }
        # [ doc = r" Writes raw bits to the register" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
            self.bits = bits;
            self
        }
        # [ doc = "Bit 2 - Assert acknowledge flag." ]
        # [ inline ( always ) ]
        pub fn aa(&mut self) -> _AAW {
            _AAW { w: self }
        }
        # [ doc = "Bit 3 - I2C interrupt flag." ]
        # [ inline ( always ) ]
        pub fn si(&mut self) -> _SIW {
            _SIW { w: self }
        }
        # [ doc = "Bit 4 - STOP flag." ]
        # [ inline ( always ) ]
        pub fn sto(&mut self) -> _STOW {
            _STOW { w: self }
        }
        # [ doc = "Bit 5 - START flag." ]
        # [ inline ( always ) ]
        pub fn sta(&mut self) -> _STAW {
            _STAW { w: self }
        }
        # [ doc = "Bit 6 - I2C interface enable." ]
        # [ inline ( always ) ]
        pub fn i2en(&mut self) -> _I2ENW {
            _I2ENW { w: self }
        }
    }
}
# [ doc = "I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed." ]
pub struct STAT {
    register: VolatileCell<u32>,
}
# [ doc = "I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed." ]
pub mod stat {
    # [ doc = r" Value read from the register" ]
    pub struct R {
        bits: u32,
    }
    impl super::STAT {
        # [ doc = r" Reads the contents of the register" ]
        # [ inline ( always ) ]
        pub fn read(&self) -> R {
            R { bits: self.register.get() }
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct STATUSR {
        bits: u8,
    }
    impl STATUSR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u8 {
            self.bits
        }
    }
    impl R {
        # [ doc = r" Value of the register as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u32 {
            self.bits
        }
        # [ doc = "Bits 3:7 - These bits give the actual status information about the I 2C interface." ]
        # [ inline ( always ) ]
        pub fn status(&self) -> STATUSR {
            let bits = {
                const MASK: u8 = 31;
                const OFFSET: u8 = 3;
                ((self.bits >> OFFSET) & MASK as u32) as u8
            };
            STATUSR { bits }
        }
    }
}
# [ doc = "I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register." ]
pub struct DAT {
    register: VolatileCell<u32>,
}
# [ doc = "I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register." ]
pub mod dat {
    # [ doc = r" Value read from the register" ]
    pub struct R {
        bits: u32,
    }
    # [ doc = r" Value to write to the register" ]
    pub struct W {
        bits: u32,
    }
    impl super::DAT {
        # [ doc = r" Modifies the contents of the register" ]
        # [ inline ( always ) ]
        pub fn modify<F>(&self, f: F)
            where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
        {
            let bits = self.register.get();
            let r = R { bits: bits };
            let mut w = W { bits: bits };
            f(&r, &mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Reads the contents of the register" ]
        # [ inline ( always ) ]
        pub fn read(&self) -> R {
            R { bits: self.register.get() }
        }
        # [ doc = r" Writes to the register" ]
        # [ inline ( always ) ]
        pub fn write<F>(&self, f: F)
            where F: FnOnce(&mut W) -> &mut W
        {
            let mut w = W::reset_value();
            f(&mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Writes the reset value to the register" ]
        # [ inline ( always ) ]
        pub fn reset(&self) {
            self.write(|w| w)
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct DATAR {
        bits: u8,
    }
    impl DATAR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u8 {
            self.bits
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _DATAW<'a> {
        w: &'a mut W,
    }
    impl<'a> _DATAW<'a> {
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(self, value: u8) -> &'a mut W {
            const MASK: u8 = 255;
            const OFFSET: u8 = 0;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    impl R {
        # [ doc = r" Value of the register as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u32 {
            self.bits
        }
        # [ doc = "Bits 0:7 - This register holds data values that have been received or are to be transmitted." ]
        # [ inline ( always ) ]
        pub fn data(&self) -> DATAR {
            let bits = {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                ((self.bits >> OFFSET) & MASK as u32) as u8
            };
            DATAR { bits }
        }
    }
    impl W {
        # [ doc = r" Reset value of the register" ]
        # [ inline ( always ) ]
        pub fn reset_value() -> W {
            W { bits: 0 }
        }
        # [ doc = r" Writes raw bits to the register" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
            self.bits = bits;
            self
        }
        # [ doc = "Bits 0:7 - This register holds data values that have been received or are to be transmitted." ]
        # [ inline ( always ) ]
        pub fn data(&mut self) -> _DATAW {
            _DATAW { w: self }
        }
    }
}
# [ doc = "I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ]
pub struct ADR0 {
    register: VolatileCell<u32>,
}
# [ doc = "I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ]
pub mod adr0 {
    # [ doc = r" Value read from the register" ]
    pub struct R {
        bits: u32,
    }
    # [ doc = r" Value to write to the register" ]
    pub struct W {
        bits: u32,
    }
    impl super::ADR0 {
        # [ doc = r" Modifies the contents of the register" ]
        # [ inline ( always ) ]
        pub fn modify<F>(&self, f: F)
            where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
        {
            let bits = self.register.get();
            let r = R { bits: bits };
            let mut w = W { bits: bits };
            f(&r, &mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Reads the contents of the register" ]
        # [ inline ( always ) ]
        pub fn read(&self) -> R {
            R { bits: self.register.get() }
        }
        # [ doc = r" Writes to the register" ]
        # [ inline ( always ) ]
        pub fn write<F>(&self, f: F)
            where F: FnOnce(&mut W) -> &mut W
        {
            let mut w = W::reset_value();
            f(&mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Writes the reset value to the register" ]
        # [ inline ( always ) ]
        pub fn reset(&self) {
            self.write(|w| w)
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct GCR {
        bits: bool,
    }
    impl GCR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bit(&self) -> bool {
            self.bits
        }
        # [ doc = r" Returns `true` if the bit is clear (0)" ]
        # [ inline ( always ) ]
        pub fn is_clear(&self) -> bool {
            !self.bit()
        }
        # [ doc = r" Returns `true` if the bit is set (1)" ]
        # [ inline ( always ) ]
        pub fn is_set(&self) -> bool {
            self.bit()
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct ADDRESSR {
        bits: u8,
    }
    impl ADDRESSR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u8 {
            self.bits
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _GCW<'a> {
        w: &'a mut W,
    }
    impl<'a> _GCW<'a> {
        # [ doc = r" Sets the field bit" ]
        pub fn set(self) -> &'a mut W {
            self.bit(true)
        }
        # [ doc = r" Clears the field bit" ]
        pub fn clear(self) -> &'a mut W {
            self.bit(false)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 0;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _ADDRESSW<'a> {
        w: &'a mut W,
    }
    impl<'a> _ADDRESSW<'a> {
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(self, value: u8) -> &'a mut W {
            const MASK: u8 = 127;
            const OFFSET: u8 = 1;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    impl R {
        # [ doc = r" Value of the register as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u32 {
            self.bits
        }
        # [ doc = "Bit 0 - General Call enable bit." ]
        # [ inline ( always ) ]
        pub fn gc(&self) -> GCR {
            let bits = {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                ((self.bits >> OFFSET) & MASK as u32) != 0
            };
            GCR { bits }
        }
        # [ doc = "Bits 1:7 - The I2C device address for slave mode." ]
        # [ inline ( always ) ]
        pub fn address(&self) -> ADDRESSR {
            let bits = {
                const MASK: u8 = 127;
                const OFFSET: u8 = 1;
                ((self.bits >> OFFSET) & MASK as u32) as u8
            };
            ADDRESSR { bits }
        }
    }
    impl W {
        # [ doc = r" Reset value of the register" ]
        # [ inline ( always ) ]
        pub fn reset_value() -> W {
            W { bits: 0 }
        }
        # [ doc = r" Writes raw bits to the register" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
            self.bits = bits;
            self
        }
        # [ doc = "Bit 0 - General Call enable bit." ]
        # [ inline ( always ) ]
        pub fn gc(&mut self) -> _GCW {
            _GCW { w: self }
        }
        # [ doc = "Bits 1:7 - The I2C device address for slave mode." ]
        # [ inline ( always ) ]
        pub fn address(&mut self) -> _ADDRESSW {
            _ADDRESSW { w: self }
        }
    }
}
# [ doc = "SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock." ]
pub struct SCLH {
    register: VolatileCell<u32>,
}
# [ doc = "SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock." ]
pub mod sclh {
    # [ doc = r" Value read from the register" ]
    pub struct R {
        bits: u32,
    }
    # [ doc = r" Value to write to the register" ]
    pub struct W {
        bits: u32,
    }
    impl super::SCLH {
        # [ doc = r" Modifies the contents of the register" ]
        # [ inline ( always ) ]
        pub fn modify<F>(&self, f: F)
            where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
        {
            let bits = self.register.get();
            let r = R { bits: bits };
            let mut w = W { bits: bits };
            f(&r, &mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Reads the contents of the register" ]
        # [ inline ( always ) ]
        pub fn read(&self) -> R {
            R { bits: self.register.get() }
        }
        # [ doc = r" Writes to the register" ]
        # [ inline ( always ) ]
        pub fn write<F>(&self, f: F)
            where F: FnOnce(&mut W) -> &mut W
        {
            let mut w = W::reset_value();
            f(&mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Writes the reset value to the register" ]
        # [ inline ( always ) ]
        pub fn reset(&self) {
            self.write(|w| w)
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct SCLHR {
        bits: u16,
    }
    impl SCLHR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u16 {
            self.bits
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _SCLHW<'a> {
        w: &'a mut W,
    }
    impl<'a> _SCLHW<'a> {
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(self, value: u16) -> &'a mut W {
            const MASK: u16 = 65535;
            const OFFSET: u8 = 0;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    impl R {
        # [ doc = r" Value of the register as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u32 {
            self.bits
        }
        # [ doc = "Bits 0:15 - Count for SCL HIGH time period selection." ]
        # [ inline ( always ) ]
        pub fn sclh(&self) -> SCLHR {
            let bits = {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                ((self.bits >> OFFSET) & MASK as u32) as u16
            };
            SCLHR { bits }
        }
    }
    impl W {
        # [ doc = r" Reset value of the register" ]
        # [ inline ( always ) ]
        pub fn reset_value() -> W {
            W { bits: 4 }
        }
        # [ doc = r" Writes raw bits to the register" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
            self.bits = bits;
            self
        }
        # [ doc = "Bits 0:15 - Count for SCL HIGH time period selection." ]
        # [ inline ( always ) ]
        pub fn sclh(&mut self) -> _SCLHW {
            _SCLHW { w: self }
        }
    }
}
# [ doc = "SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. SCLL and SCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode." ]
pub struct SCLL {
    register: VolatileCell<u32>,
}
# [ doc = "SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. SCLL and SCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode." ]
pub mod scll {
    # [ doc = r" Value read from the register" ]
    pub struct R {
        bits: u32,
    }
    # [ doc = r" Value to write to the register" ]
    pub struct W {
        bits: u32,
    }
    impl super::SCLL {
        # [ doc = r" Modifies the contents of the register" ]
        # [ inline ( always ) ]
        pub fn modify<F>(&self, f: F)
            where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
        {
            let bits = self.register.get();
            let r = R { bits: bits };
            let mut w = W { bits: bits };
            f(&r, &mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Reads the contents of the register" ]
        # [ inline ( always ) ]
        pub fn read(&self) -> R {
            R { bits: self.register.get() }
        }
        # [ doc = r" Writes to the register" ]
        # [ inline ( always ) ]
        pub fn write<F>(&self, f: F)
            where F: FnOnce(&mut W) -> &mut W
        {
            let mut w = W::reset_value();
            f(&mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Writes the reset value to the register" ]
        # [ inline ( always ) ]
        pub fn reset(&self) {
            self.write(|w| w)
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct SCLLR {
        bits: u16,
    }
    impl SCLLR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u16 {
            self.bits
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _SCLLW<'a> {
        w: &'a mut W,
    }
    impl<'a> _SCLLW<'a> {
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(self, value: u16) -> &'a mut W {
            const MASK: u16 = 65535;
            const OFFSET: u8 = 0;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    impl R {
        # [ doc = r" Value of the register as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u32 {
            self.bits
        }
        # [ doc = "Bits 0:15 - Count for SCL low time period selection." ]
        # [ inline ( always ) ]
        pub fn scll(&self) -> SCLLR {
            let bits = {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                ((self.bits >> OFFSET) & MASK as u32) as u16
            };
            SCLLR { bits }
        }
    }
    impl W {
        # [ doc = r" Reset value of the register" ]
        # [ inline ( always ) ]
        pub fn reset_value() -> W {
            W { bits: 4 }
        }
        # [ doc = r" Writes raw bits to the register" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
            self.bits = bits;
            self
        }
        # [ doc = "Bits 0:15 - Count for SCL low time period selection." ]
        # [ inline ( always ) ]
        pub fn scll(&mut self) -> _SCLLW {
            _SCLLW { w: self }
        }
    }
}
# [ doc = "I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register." ]
pub struct CONCLR {
    register: VolatileCell<u32>,
}
# [ doc = "I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register." ]
pub mod conclr {
    # [ doc = r" Value to write to the register" ]
    pub struct W {
        bits: u32,
    }
    impl super::CONCLR {
        # [ doc = r" Writes to the register" ]
        # [ inline ( always ) ]
        pub fn write<F>(&self, f: F)
            where F: FnOnce(&mut W) -> &mut W
        {
            let mut w = W::reset_value();
            f(&mut w);
            self.register.set(w.bits);
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _AACW<'a> {
        w: &'a mut W,
    }
    impl<'a> _AACW<'a> {
        # [ doc = r" Sets the field bit" ]
        pub fn set(self) -> &'a mut W {
            self.bit(true)
        }
        # [ doc = r" Clears the field bit" ]
        pub fn clear(self) -> &'a mut W {
            self.bit(false)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 2;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _SICW<'a> {
        w: &'a mut W,
    }
    impl<'a> _SICW<'a> {
        # [ doc = r" Sets the field bit" ]
        pub fn set(self) -> &'a mut W {
            self.bit(true)
        }
        # [ doc = r" Clears the field bit" ]
        pub fn clear(self) -> &'a mut W {
            self.bit(false)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 3;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _STACW<'a> {
        w: &'a mut W,
    }
    impl<'a> _STACW<'a> {
        # [ doc = r" Sets the field bit" ]
        pub fn set(self) -> &'a mut W {
            self.bit(true)
        }
        # [ doc = r" Clears the field bit" ]
        pub fn clear(self) -> &'a mut W {
            self.bit(false)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 5;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _I2ENCW<'a> {
        w: &'a mut W,
    }
    impl<'a> _I2ENCW<'a> {
        # [ doc = r" Sets the field bit" ]
        pub fn set(self) -> &'a mut W {
            self.bit(true)
        }
        # [ doc = r" Clears the field bit" ]
        pub fn clear(self) -> &'a mut W {
            self.bit(false)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 6;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    impl W {
        # [ doc = r" Reset value of the register" ]
        # [ inline ( always ) ]
        pub fn reset_value() -> W {
            W { bits: 0 }
        }
        # [ doc = r" Writes raw bits to the register" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
            self.bits = bits;
            self
        }
        # [ doc = "Bit 2 - Assert acknowledge Clear bit." ]
        # [ inline ( always ) ]
        pub fn aac(&mut self) -> _AACW {
            _AACW { w: self }
        }
        # [ doc = "Bit 3 - I2C interrupt Clear bit." ]
        # [ inline ( always ) ]
        pub fn sic(&mut self) -> _SICW {
            _SICW { w: self }
        }
        # [ doc = "Bit 5 - START flag Clear bit." ]
        # [ inline ( always ) ]
        pub fn stac(&mut self) -> _STACW {
            _STACW { w: self }
        }
        # [ doc = "Bit 6 - I2C interface Disable bit." ]
        # [ inline ( always ) ]
        pub fn i2enc(&mut self) -> _I2ENCW {
            _I2ENCW { w: self }
        }
    }
}
# [ doc = "Monitor mode control register." ]
pub struct MMCTRL {
    register: VolatileCell<u32>,
}
# [ doc = "Monitor mode control register." ]
pub mod mmctrl {
    # [ doc = r" Value read from the register" ]
    pub struct R {
        bits: u32,
    }
    # [ doc = r" Value to write to the register" ]
    pub struct W {
        bits: u32,
    }
    impl super::MMCTRL {
        # [ doc = r" Modifies the contents of the register" ]
        # [ inline ( always ) ]
        pub fn modify<F>(&self, f: F)
            where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
        {
            let bits = self.register.get();
            let r = R { bits: bits };
            let mut w = W { bits: bits };
            f(&r, &mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Reads the contents of the register" ]
        # [ inline ( always ) ]
        pub fn read(&self) -> R {
            R { bits: self.register.get() }
        }
        # [ doc = r" Writes to the register" ]
        # [ inline ( always ) ]
        pub fn write<F>(&self, f: F)
            where F: FnOnce(&mut W) -> &mut W
        {
            let mut w = W::reset_value();
            f(&mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Writes the reset value to the register" ]
        # [ inline ( always ) ]
        pub fn reset(&self) {
            self.write(|w| w)
        }
    }
    # [ doc = "Possible values of the field `MM_ENA`" ]
    # [ derive ( Clone , Copy , Debug , PartialEq ) ]
    pub enum MM_ENAR {
        # [ doc = "Monitor mode disabled." ]
        MONITOR_MODE_DISABLE,
        # [ doc = "The I 2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line." ]
        THE_I_2C_MODULE_WILL,
    }
    impl MM_ENAR {
        # [ doc = r" Returns `true` if the bit is clear (0)" ]
        # [ inline ( always ) ]
        pub fn is_clear(&self) -> bool {
            !self.bit()
        }
        # [ doc = r" Returns `true` if the bit is set (1)" ]
        # [ inline ( always ) ]
        pub fn is_set(&self) -> bool {
            self.bit()
        }
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bit(&self) -> bool {
            match *self {
                MM_ENAR::MONITOR_MODE_DISABLE => false,
                MM_ENAR::THE_I_2C_MODULE_WILL => true,
            }
        }
        # [ allow ( missing_docs ) ]
        # [ doc ( hidden ) ]
        # [ inline ( always ) ]
        pub fn _from(value: bool) -> MM_ENAR {
            match value {
                false => MM_ENAR::MONITOR_MODE_DISABLE,
                true => MM_ENAR::THE_I_2C_MODULE_WILL,
            }
        }
        # [ doc = "Checks if the value of the field is `MONITOR_MODE_DISABLE`" ]
        # [ inline ( always ) ]
        pub fn is_monitor_mode_disable(&self) -> bool {
            *self == MM_ENAR::MONITOR_MODE_DISABLE
        }
        # [ doc = "Checks if the value of the field is `THE_I_2C_MODULE_WILL`" ]
        # [ inline ( always ) ]
        pub fn is_the_i_2c_module_will(&self) -> bool {
            *self == MM_ENAR::THE_I_2C_MODULE_WILL
        }
    }
    # [ doc = "Possible values of the field `ENA_SCL`" ]
    # [ derive ( Clone , Copy , Debug , PartialEq ) ]
    pub enum ENA_SCLR {
        # [ doc = "When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line." ]
        WHEN_THIS_BIT_IS_CLE,
        # [ doc = "When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.[1]" ]
        WHEN_THIS_BIT_IS_SET,
    }
    impl ENA_SCLR {
        # [ doc = r" Returns `true` if the bit is clear (0)" ]
        # [ inline ( always ) ]
        pub fn is_clear(&self) -> bool {
            !self.bit()
        }
        # [ doc = r" Returns `true` if the bit is set (1)" ]
        # [ inline ( always ) ]
        pub fn is_set(&self) -> bool {
            self.bit()
        }
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bit(&self) -> bool {
            match *self {
                ENA_SCLR::WHEN_THIS_BIT_IS_CLE => false,
                ENA_SCLR::WHEN_THIS_BIT_IS_SET => true,
            }
        }
        # [ allow ( missing_docs ) ]
        # [ doc ( hidden ) ]
        # [ inline ( always ) ]
        pub fn _from(value: bool) -> ENA_SCLR {
            match value {
                false => ENA_SCLR::WHEN_THIS_BIT_IS_CLE,
                true => ENA_SCLR::WHEN_THIS_BIT_IS_SET,
            }
        }
        # [ doc = "Checks if the value of the field is `WHEN_THIS_BIT_IS_CLE`" ]
        # [ inline ( always ) ]
        pub fn is_when_this_bit_is_cle(&self) -> bool {
            *self == ENA_SCLR::WHEN_THIS_BIT_IS_CLE
        }
        # [ doc = "Checks if the value of the field is `WHEN_THIS_BIT_IS_SET`" ]
        # [ inline ( always ) ]
        pub fn is_when_this_bit_is_set(&self) -> bool {
            *self == ENA_SCLR::WHEN_THIS_BIT_IS_SET
        }
    }
    # [ doc = "Possible values of the field `MATCH_ALL`" ]
    # [ derive ( Clone , Copy , Debug , PartialEq ) ]
    pub enum MATCH_ALLR {
        # [ doc = "When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above.   That is, the module will respond as a normal slave as far as address-recognition is concerned." ]
        WHEN_THIS_BIT_IS_CLE,
        # [ doc = "When this bit is set to 1 and the I2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus." ]
        WHEN_THIS_BIT_IS_SET,
    }
    impl MATCH_ALLR {
        # [ doc = r" Returns `true` if the bit is clear (0)" ]
        # [ inline ( always ) ]
        pub fn is_clear(&self) -> bool {
            !self.bit()
        }
        # [ doc = r" Returns `true` if the bit is set (1)" ]
        # [ inline ( always ) ]
        pub fn is_set(&self) -> bool {
            self.bit()
        }
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bit(&self) -> bool {
            match *self {
                MATCH_ALLR::WHEN_THIS_BIT_IS_CLE => false,
                MATCH_ALLR::WHEN_THIS_BIT_IS_SET => true,
            }
        }
        # [ allow ( missing_docs ) ]
        # [ doc ( hidden ) ]
        # [ inline ( always ) ]
        pub fn _from(value: bool) -> MATCH_ALLR {
            match value {
                false => MATCH_ALLR::WHEN_THIS_BIT_IS_CLE,
                true => MATCH_ALLR::WHEN_THIS_BIT_IS_SET,
            }
        }
        # [ doc = "Checks if the value of the field is `WHEN_THIS_BIT_IS_CLE`" ]
        # [ inline ( always ) ]
        pub fn is_when_this_bit_is_cle(&self) -> bool {
            *self == MATCH_ALLR::WHEN_THIS_BIT_IS_CLE
        }
        # [ doc = "Checks if the value of the field is `WHEN_THIS_BIT_IS_SET`" ]
        # [ inline ( always ) ]
        pub fn is_when_this_bit_is_set(&self) -> bool {
            *self == MATCH_ALLR::WHEN_THIS_BIT_IS_SET
        }
    }
    # [ doc = "Values that can be written to the field `MM_ENA`" ]
    pub enum MM_ENAW {
        # [ doc = "Monitor mode disabled." ]
        MONITOR_MODE_DISABLE,
        # [ doc = "The I 2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line." ]
        THE_I_2C_MODULE_WILL,
    }
    impl MM_ENAW {
        # [ allow ( missing_docs ) ]
        # [ doc ( hidden ) ]
        # [ inline ( always ) ]
        pub fn _bits(&self) -> bool {
            match *self {
                MM_ENAW::MONITOR_MODE_DISABLE => false,
                MM_ENAW::THE_I_2C_MODULE_WILL => true,
            }
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _MM_ENAW<'a> {
        w: &'a mut W,
    }
    impl<'a> _MM_ENAW<'a> {
        # [ doc = r" Writes `variant` to the field" ]
        # [ inline ( always ) ]
        pub fn variant(self, variant: MM_ENAW) -> &'a mut W {
            {
                self.bit(variant._bits())
            }
        }
        # [ doc = "Monitor mode disabled." ]
        # [ inline ( always ) ]
        pub fn monitor_mode_disable(self) -> &'a mut W {
            self.variant(MM_ENAW::MONITOR_MODE_DISABLE)
        }
        # [ doc = "The I 2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line." ]
        # [ inline ( always ) ]
        pub fn the_i_2c_module_will(self) -> &'a mut W {
            self.variant(MM_ENAW::THE_I_2C_MODULE_WILL)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 0;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    # [ doc = "Values that can be written to the field `ENA_SCL`" ]
    pub enum ENA_SCLW {
        # [ doc = "When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line." ]
        WHEN_THIS_BIT_IS_CLE,
        # [ doc = "When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.[1]" ]
        WHEN_THIS_BIT_IS_SET,
    }
    impl ENA_SCLW {
        # [ allow ( missing_docs ) ]
        # [ doc ( hidden ) ]
        # [ inline ( always ) ]
        pub fn _bits(&self) -> bool {
            match *self {
                ENA_SCLW::WHEN_THIS_BIT_IS_CLE => false,
                ENA_SCLW::WHEN_THIS_BIT_IS_SET => true,
            }
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _ENA_SCLW<'a> {
        w: &'a mut W,
    }
    impl<'a> _ENA_SCLW<'a> {
        # [ doc = r" Writes `variant` to the field" ]
        # [ inline ( always ) ]
        pub fn variant(self, variant: ENA_SCLW) -> &'a mut W {
            {
                self.bit(variant._bits())
            }
        }
        # [ doc = "When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line." ]
        # [ inline ( always ) ]
        pub fn when_this_bit_is_cle(self) -> &'a mut W {
            self.variant(ENA_SCLW::WHEN_THIS_BIT_IS_CLE)
        }
        # [ doc = "When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.[1]" ]
        # [ inline ( always ) ]
        pub fn when_this_bit_is_set(self) -> &'a mut W {
            self.variant(ENA_SCLW::WHEN_THIS_BIT_IS_SET)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 1;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    # [ doc = "Values that can be written to the field `MATCH_ALL`" ]
    pub enum MATCH_ALLW {
        # [ doc = "When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above.   That is, the module will respond as a normal slave as far as address-recognition is concerned." ]
        WHEN_THIS_BIT_IS_CLE,
        # [ doc = "When this bit is set to 1 and the I2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus." ]
        WHEN_THIS_BIT_IS_SET,
    }
    impl MATCH_ALLW {
        # [ allow ( missing_docs ) ]
        # [ doc ( hidden ) ]
        # [ inline ( always ) ]
        pub fn _bits(&self) -> bool {
            match *self {
                MATCH_ALLW::WHEN_THIS_BIT_IS_CLE => false,
                MATCH_ALLW::WHEN_THIS_BIT_IS_SET => true,
            }
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _MATCH_ALLW<'a> {
        w: &'a mut W,
    }
    impl<'a> _MATCH_ALLW<'a> {
        # [ doc = r" Writes `variant` to the field" ]
        # [ inline ( always ) ]
        pub fn variant(self, variant: MATCH_ALLW) -> &'a mut W {
            {
                self.bit(variant._bits())
            }
        }
        # [ doc = "When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above. That is, the module will respond as a normal slave as far as address-recognition is concerned." ]
        # [ inline ( always ) ]
        pub fn when_this_bit_is_cle(self) -> &'a mut W {
            self.variant(MATCH_ALLW::WHEN_THIS_BIT_IS_CLE)
        }
        # [ doc = "When this bit is set to 1 and the I2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus." ]
        # [ inline ( always ) ]
        pub fn when_this_bit_is_set(self) -> &'a mut W {
            self.variant(MATCH_ALLW::WHEN_THIS_BIT_IS_SET)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 2;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    impl R {
        # [ doc = r" Value of the register as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u32 {
            self.bits
        }
        # [ doc = "Bit 0 - Monitor mode enable." ]
        # [ inline ( always ) ]
        pub fn mm_ena(&self) -> MM_ENAR {
            MM_ENAR::_from({
                               const MASK: bool = true;
                               const OFFSET: u8 = 0;
                               ((self.bits >> OFFSET) & MASK as u32) != 0
                           })
        }
        # [ doc = "Bit 1 - SCL output enable." ]
        # [ inline ( always ) ]
        pub fn ena_scl(&self) -> ENA_SCLR {
            ENA_SCLR::_from({
                                const MASK: bool = true;
                                const OFFSET: u8 = 1;
                                ((self.bits >> OFFSET) & MASK as u32) != 0
                            })
        }
        # [ doc = "Bit 2 - Select interrupt register match." ]
        # [ inline ( always ) ]
        pub fn match_all(&self) -> MATCH_ALLR {
            MATCH_ALLR::_from({
                                  const MASK: bool = true;
                                  const OFFSET: u8 = 2;
                                  ((self.bits >> OFFSET) & MASK as u32) != 0
                              })
        }
    }
    impl W {
        # [ doc = r" Reset value of the register" ]
        # [ inline ( always ) ]
        pub fn reset_value() -> W {
            W { bits: 0 }
        }
        # [ doc = r" Writes raw bits to the register" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
            self.bits = bits;
            self
        }
        # [ doc = "Bit 0 - Monitor mode enable." ]
        # [ inline ( always ) ]
        pub fn mm_ena(&mut self) -> _MM_ENAW {
            _MM_ENAW { w: self }
        }
        # [ doc = "Bit 1 - SCL output enable." ]
        # [ inline ( always ) ]
        pub fn ena_scl(&mut self) -> _ENA_SCLW {
            _ENA_SCLW { w: self }
        }
        # [ doc = "Bit 2 - Select interrupt register match." ]
        # [ inline ( always ) ]
        pub fn match_all(&mut self) -> _MATCH_ALLW {
            _MATCH_ALLW { w: self }
        }
    }
}
# [ doc = "I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ]
pub struct ADR {
    register: VolatileCell<u32>,
}
# [ doc = "I2C Slave Address Register. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address." ]
pub mod adr {
    # [ doc = r" Value read from the register" ]
    pub struct R {
        bits: u32,
    }
    # [ doc = r" Value to write to the register" ]
    pub struct W {
        bits: u32,
    }
    impl super::ADR {
        # [ doc = r" Modifies the contents of the register" ]
        # [ inline ( always ) ]
        pub fn modify<F>(&self, f: F)
            where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
        {
            let bits = self.register.get();
            let r = R { bits: bits };
            let mut w = W { bits: bits };
            f(&r, &mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Reads the contents of the register" ]
        # [ inline ( always ) ]
        pub fn read(&self) -> R {
            R { bits: self.register.get() }
        }
        # [ doc = r" Writes to the register" ]
        # [ inline ( always ) ]
        pub fn write<F>(&self, f: F)
            where F: FnOnce(&mut W) -> &mut W
        {
            let mut w = W::reset_value();
            f(&mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Writes the reset value to the register" ]
        # [ inline ( always ) ]
        pub fn reset(&self) {
            self.write(|w| w)
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct GCR {
        bits: bool,
    }
    impl GCR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bit(&self) -> bool {
            self.bits
        }
        # [ doc = r" Returns `true` if the bit is clear (0)" ]
        # [ inline ( always ) ]
        pub fn is_clear(&self) -> bool {
            !self.bit()
        }
        # [ doc = r" Returns `true` if the bit is set (1)" ]
        # [ inline ( always ) ]
        pub fn is_set(&self) -> bool {
            self.bit()
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct ADDRESSR {
        bits: u8,
    }
    impl ADDRESSR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u8 {
            self.bits
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _GCW<'a> {
        w: &'a mut W,
    }
    impl<'a> _GCW<'a> {
        # [ doc = r" Sets the field bit" ]
        pub fn set(self) -> &'a mut W {
            self.bit(true)
        }
        # [ doc = r" Clears the field bit" ]
        pub fn clear(self) -> &'a mut W {
            self.bit(false)
        }
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub fn bit(self, value: bool) -> &'a mut W {
            const MASK: bool = true;
            const OFFSET: u8 = 0;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _ADDRESSW<'a> {
        w: &'a mut W,
    }
    impl<'a> _ADDRESSW<'a> {
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(self, value: u8) -> &'a mut W {
            const MASK: u8 = 127;
            const OFFSET: u8 = 1;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    impl R {
        # [ doc = r" Value of the register as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u32 {
            self.bits
        }
        # [ doc = "Bit 0 - General Call enable bit." ]
        # [ inline ( always ) ]
        pub fn gc(&self) -> GCR {
            let bits = {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                ((self.bits >> OFFSET) & MASK as u32) != 0
            };
            GCR { bits }
        }
        # [ doc = "Bits 1:7 - The I2C device address for slave mode." ]
        # [ inline ( always ) ]
        pub fn address(&self) -> ADDRESSR {
            let bits = {
                const MASK: u8 = 127;
                const OFFSET: u8 = 1;
                ((self.bits >> OFFSET) & MASK as u32) as u8
            };
            ADDRESSR { bits }
        }
    }
    impl W {
        # [ doc = r" Reset value of the register" ]
        # [ inline ( always ) ]
        pub fn reset_value() -> W {
            W { bits: 0 }
        }
        # [ doc = r" Writes raw bits to the register" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
            self.bits = bits;
            self
        }
        # [ doc = "Bit 0 - General Call enable bit." ]
        # [ inline ( always ) ]
        pub fn gc(&mut self) -> _GCW {
            _GCW { w: self }
        }
        # [ doc = "Bits 1:7 - The I2C device address for slave mode." ]
        # [ inline ( always ) ]
        pub fn address(&mut self) -> _ADDRESSW {
            _ADDRESSW { w: self }
        }
    }
}
# [ doc = "Data buffer register. The contents of the 8 MSBs of the DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus." ]
pub struct DATA_BUFFER {
    register: VolatileCell<u32>,
}
# [ doc = "Data buffer register. The contents of the 8 MSBs of the DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus." ]
pub mod data_buffer {
    # [ doc = r" Value read from the register" ]
    pub struct R {
        bits: u32,
    }
    impl super::DATA_BUFFER {
        # [ doc = r" Reads the contents of the register" ]
        # [ inline ( always ) ]
        pub fn read(&self) -> R {
            R { bits: self.register.get() }
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct DATAR {
        bits: u8,
    }
    impl DATAR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u8 {
            self.bits
        }
    }
    impl R {
        # [ doc = r" Value of the register as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u32 {
            self.bits
        }
        # [ doc = "Bits 0:7 - This register holds contents of the 8 MSBs of the DAT shift register." ]
        # [ inline ( always ) ]
        pub fn data(&self) -> DATAR {
            let bits = {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                ((self.bits >> OFFSET) & MASK as u32) as u8
            };
            DATAR { bits }
        }
    }
}
# [ doc = "I2C Slave address mask register" ]
pub struct MASK {
    register: VolatileCell<u32>,
}
# [ doc = "I2C Slave address mask register" ]
pub mod mask {
    # [ doc = r" Value read from the register" ]
    pub struct R {
        bits: u32,
    }
    # [ doc = r" Value to write to the register" ]
    pub struct W {
        bits: u32,
    }
    impl super::MASK {
        # [ doc = r" Modifies the contents of the register" ]
        # [ inline ( always ) ]
        pub fn modify<F>(&self, f: F)
            where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
        {
            let bits = self.register.get();
            let r = R { bits: bits };
            let mut w = W { bits: bits };
            f(&r, &mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Reads the contents of the register" ]
        # [ inline ( always ) ]
        pub fn read(&self) -> R {
            R { bits: self.register.get() }
        }
        # [ doc = r" Writes to the register" ]
        # [ inline ( always ) ]
        pub fn write<F>(&self, f: F)
            where F: FnOnce(&mut W) -> &mut W
        {
            let mut w = W::reset_value();
            f(&mut w);
            self.register.set(w.bits);
        }
        # [ doc = r" Writes the reset value to the register" ]
        # [ inline ( always ) ]
        pub fn reset(&self) {
            self.write(|w| w)
        }
    }
    # [ doc = r" Value of the field" ]
    pub struct MASKR {
        bits: u8,
    }
    impl MASKR {
        # [ doc = r" Value of the field as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u8 {
            self.bits
        }
    }
    # [ doc = r" Proxy" ]
    pub struct _MASKW<'a> {
        w: &'a mut W,
    }
    impl<'a> _MASKW<'a> {
        # [ doc = r" Writes raw bits to the field" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(self, value: u8) -> &'a mut W {
            const MASK: u8 = 127;
            const OFFSET: u8 = 1;
            self.w.bits &= !((MASK as u32) << OFFSET);
            self.w.bits |= ((value & MASK) as u32) << OFFSET;
            self.w
        }
    }
    impl R {
        # [ doc = r" Value of the register as raw bits" ]
        # [ inline ( always ) ]
        pub fn bits(&self) -> u32 {
            self.bits
        }
        # [ doc = "Bits 1:7 - Mask bits." ]
        # [ inline ( always ) ]
        pub fn mask(&self) -> MASKR {
            let bits = {
                const MASK: u8 = 127;
                const OFFSET: u8 = 1;
                ((self.bits >> OFFSET) & MASK as u32) as u8
            };
            MASKR { bits }
        }
    }
    impl W {
        # [ doc = r" Reset value of the register" ]
        # [ inline ( always ) ]
        pub fn reset_value() -> W {
            W { bits: 0 }
        }
        # [ doc = r" Writes raw bits to the register" ]
        # [ inline ( always ) ]
        pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
            self.bits = bits;
            self
        }
        # [ doc = "Bits 1:7 - Mask bits." ]
        # [ inline ( always ) ]
        pub fn mask(&mut self) -> _MASKW {
            _MASKW { w: self }
        }
    }
}
# [ doc = "I2C bus interface" ]
pub struct I2C0 {
    register_block: RegisterBlock,
}
impl Deref for I2C0 {
    type Target = RegisterBlock;
    fn deref(&self) -> &RegisterBlock {
        &self.register_block
    }
}
# [ doc = "I2C1" ]
pub const I2C1: Peripheral<I2C1> = unsafe { Peripheral::new(1074118656) };
# [ doc = r" Register block" ]
pub struct I2C1 {
    register_block: RegisterBlock,
}
impl Deref for I2C1 {
    type Target = RegisterBlock;
    fn deref(&self) -> &RegisterBlock {
        &self.register_block
    }
}
# [ doc = "I2C2" ]
pub const I2C2: Peripheral<I2C2> = unsafe { Peripheral::new(1074397184) };
# [ doc = r" Register block" ]
pub struct I2C2 {
    register_block: RegisterBlock,
}
impl Deref for I2C2 {
    type Target = RegisterBlock;
    fn deref(&self) -> &RegisterBlock {
        &self.register_block
    }
}
